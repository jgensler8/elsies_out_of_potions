import argparse
import logging
from dataclasses import dataclass
from pathlib import Path
import hashlib
from PIL import Image
from typing import Tuple


def load_image(filename) -> Image.Image:
    """Load the image and convert it to RGBA (if not already)."""
    img = Image.open(filename).convert("RGBA")
    return img


def split_image_into_tiles(image, tile_width=8, tile_height=8) -> list[Image.Image]:
    """Split the image into tiles of size 8x8."""
    width, height = image.size
    tiles = []
    for y in range(0, height, tile_height):
        for x in range(0, width, tile_width):
            tile = image.crop((x, y, x + tile_width, y + tile_height))
            tiles.append(tile)
    return tiles

def tile_hash(tile: Image.Image):
    return hashlib.sha256(tile.tobytes()).hexdigest()


def deduplicate_tiles(tiles: list[Image.Image]) -> Tuple[set[str], list[Image.Image]]:
    """Remove duplicate tiles and return a list of unique tiles."""
    unique_tile_hashes: set[str] = set()
    unique_tiles: list[Image.Image] = []
    for tile in tiles:
        hash = tile_hash(tile)
        if hash not in unique_tile_hashes:
            unique_tile_hashes.add(hash)
            unique_tiles.append(tile)
    return unique_tile_hashes, unique_tiles


OUT_C_TEMPLATE = """// AUTOGENERATED png2asset_map.py
#include <stdint.h>
#include <gbdk/platform.h>
const uint8_t {identifier}_tiles[{tile_elements}] = {{
{tile_data}
}};
const unsigned char {identifier}_map[{map_elements}] = {{
{map_data}
}};
"""

OUT_H_TEMPLATE = """// AUTOGENERATED png2asset_map.py
#include <stdint.h>
#include <gbdk/platform.h>
//#define {identifier}_TILE_ORIGIN 0
#define {identifier}_TILE_W 8
#define {identifier}_TILE_H 8
#define {identifier}_WIDTH {px_width}
#define {identifier}_HEIGHT {px_height}
#define {identifier}_TILE_COUNT {tile_count}
#define {identifier}_TILE_OVERLAP {tile_overlap}
//#define {identifier}_PALETTE_COUNT 1
//#define {identifier}_COLORS_PER_PALETTE 4
//#define {identifier}_TOTAL_COLORS 4
//#define {identifier}_MAP_ATTRIBUTES 0
extern const unsigned char {identifier}_map[{map_elements}];
//#define {identifier}_map_attributes {identifier}_map

//BANKREF_EXTERN({identifier})

//extern const palette_color_t {identifier}_palettes[4];
extern const uint8_t {identifier}_tiles[{tile_elements}];
"""

# low bit for palette, so only just gray (01) and very dark gray (11) need the extra bit to differentiate
def pillow_rgba_to_left_hex(rgba: Tuple[int, int, int, int]) -> str:
    if rgba[3] == 0:
        return "0"
    if rgba == (139, 172, 15, 255):
        return "1"
    if rgba == (48, 98, 48, 255):
        return "0"
    if rgba == (15, 56, 15, 255):
        return "1"
    return "0"


# high bit for palette, so the dimmer colors (white(00), just gray(01)) have lower value
# the darker/fuller colors (very gray(10), black(11)) have higher value
def pillow_rgba_to_right_hex(rgba: Tuple[int, int, int, int]) -> str:
    if rgba[3] == 0:
        return "0"
    if rgba == (139, 172, 15, 255):
        return "0"
    if rgba == (48, 98, 48, 255):
        return "1"
    if rgba == (15, 56, 15, 255):
        return "1"
    return "0"


@dataclass
class Item:
    filename: str
    identifier: str
    img: Image.Image
    tiles: list[Image.Image]
    unique_tiles: list[Image.Image]
    unique_tile_hashes: set[str]


def build_tile_data(tiles: list[Image.Image]) -> str:
    s = ""
    for tile_num, tile in enumerate(tiles):
        data = list(tile.getdata())
        s += f"// tile {tile_num}\n"
        # four pixels in a tile create two hex values:
        # the left controls palette low: 0x21 == 0010 0001, so
        # the right controls palette high: 0x00
        # 0x(first four bits pal low)(last four bits pal low)
        # 0x(first four bits pal high)(last for bits pal high)
        # we have four colors: 00, 01, 10, 11 and these get "split" between the two hex value
        # so 01 (only a bit gray) would contribute 1 to the left and 0 to the right
        for line_start in range(0, len(data), 8):
            pixel_group = data[line_start : line_start + 8]
            first_hex = int(
                "".join([pillow_rgba_to_left_hex(rgba) for rgba in pixel_group]), 2
            )
            second_hex = int(
                "".join([pillow_rgba_to_right_hex(rgba) for rgba in pixel_group]), 2
            )
            s += f"{hex(first_hex)},{hex(second_hex)},\n"
    return s


def build_map_data(i: Item) -> str:
    s = ""
    tiles_high = int(i.img.height / 8)
    tiles_wide = int(i.img.width / 8)
    for y in range(tiles_high):
        for x in range(tiles_wide):
            tile = i.tiles[y * tiles_wide + x]
            idx = i.unique_tiles.index(tile)
            s += f"{hex(idx)},"
        s += "\n"
    return s


def reorder_unique_tiles(item: Item, intersection_hashes: set[str]) -> Item:
    intersection_tiles = []
    other_tiles = []
    tile_hashes = [(t, tile_hash(t)) for t in item.unique_tiles]
    tile_hashes.sort(key=lambda tup: tup[1])
    for t, hash in tile_hashes:
        if hash in intersection_hashes:
            intersection_tiles.append(t)
        else:
            other_tiles.append(t)
    item.unique_tiles = intersection_tiles + other_tiles


def save_outputs(items: list[Item], out_dir: str):
    intersection_hashes = items[0].unique_tile_hashes
    for i in items[1:]:
        intersection_hashes = intersection_hashes.intersection(i.unique_tile_hashes)
    print(len(intersection_hashes))
    for i in items:
        reorder_unique_tiles(i, intersection_hashes)
        format_args = {
            "identifier": i.identifier,
            "px_width": i.img.width,
            "px_height": i.img.height,
            "tile_count": len(i.unique_tiles),
            "tile_elements": len(i.unique_tiles) * (16),
            "tile_data": build_tile_data(i.unique_tiles),
            "map_elements": int((i.img.width * i.img.height) / (8 * 8)),
            "map_data": build_map_data(i),
            "tile_overlap": len(intersection_hashes),
        }
        with open(f"{out_dir}/{i.identifier}.c", "w+") as f:
            f.write(OUT_C_TEMPLATE.format(**format_args))
        with open(f"{out_dir}/{i.identifier}.h", "w+") as f:
            f.write(OUT_H_TEMPLATE.format(**format_args))


def png_to_tileset(inputs: list[str], out_dir: str, max_tiles_per_image=256):
    """Main function to convert PNG to tileset."""
    items: list[Item] = []
    for input in inputs:
        img = load_image(input)
        chunk_width = 160
        for start, img_start in enumerate(range(0, img.width, chunk_width)):
            i = Item("", "", None, None, None, None)
            i.filename = input
            i.identifier = f"{Path(i.filename).stem}_{start}"
            i.img = img.crop((img_start, 0, img_start + chunk_width, img.height))
            items.append(i)

    for i in items:
        i.tiles = split_image_into_tiles(i.img)
        i.unique_tile_hashes, i.unique_tiles = deduplicate_tiles(i.tiles)
        if len(i.unique_tiles) > max_tiles_per_image:
            logging.error(
                "IMAGE WILL NOT FIT IN GB RAM, need {} tiles, have {}: {}".format(
                    max_tiles_per_image, len(i.unique_tiles), input
                )
            )
            return
    # write
    save_outputs(items=items, out_dir=out_dir)


def main():
    parser = argparse.ArgumentParser()
    parser.add_argument("--out_dir", default="gameboy_assets")
    parser.add_argument("--max_tiles_per_image", default=256)
    parser.add_argument("-i", "--inputs", nargs="*")
    args = parser.parse_args()
    png_to_tileset(
        out_dir=args.out_dir,
        max_tiles_per_image=args.max_tiles_per_image,
        inputs=args.inputs,
    )


if __name__ == "__main__":
    main()
